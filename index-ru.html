<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Git: наглядная справка</title>
  <link rel='stylesheet' type='text/css' href='visual-git-guide.css'>
  <script type="text/javascript" src='visual-git-guide.js'></script>
</head>
<body onload="replace_all_PNGs();">
  <h1 id="top">Git: наглядная справка</h1>

  <ul id="language-box">
    <li><a>На других языках <small>▼</small></a>
    <ul>
      <li class="selected">English</li>
      <li><a href='index-ja.html'>日本語</a></li>
      <li><a href='index-ko.html'>한국어</a></li>
    </ul></li>
  </ul>

  <p id="link-to-png">Если вы не видите иллюстраций, попробуйте переключиться
    на версию со <a href="?no-svg">стандартными картинками</a> (без SVG).</p>

  <p id="link-to-svg">SVG изображения были отключены.
  <a href="index.html">(Включить SVG изображения)</a></p>

  <p>На этой странице представлена краткая наглядная справка для наиболее часто
  используемых команд git.  Если вы имеете небольшой опыт работы с git, эта
  страница поможет вам закрепить ваши знания.  Если вам интересно, как был
  создан этот сайт, загляните на мой 
  <a href='http://github.com/MarkLodato/visual-git-guide'>репозиторий на
  GitHub</a>.</p>

  <h2 id="contents">Содержание</h2>
  <ol>
    <li><a href="#basic-usage">Основные команды</a></li>
    <li><a href="#conventions">Соглашения</a></li>
    <li><a href="#commands-in-detail">Подробно о командах</a>
      <ol>
        <li><a href="#diff">Diff</a></li>
        <li><a href="#commit">Commit</a></li>
        <li><a href="#checkout">Checkout</a></li>
        <li><a href="#detached">Коммит из состояния «Detached HEAD»</a></li>
        <li><a href="#reset">Reset</a></li>
        <li><a href="#merge">Merge</a></li>
        <li><a href="#cherry-pick">Cherry Pick</a></li>
        <li><a href="#rebase">Rebase</a></li>
      </ol>
    </li>
    <li><a href="#technical-notes">Технические заметки</a></li>
  </ol>

  <h2 id="basic-usage">Основные команды</h2>

  <div class="center"><img src='basic-usage.svg.png'></div>

  <p>Следующие четыре команды предназначены для копирования файлов между
  рабочей директорией, сценой (так же известной как «индекс») и историей
  (представленной в форме коммитов).</p>

  <ul>

    <li><code>git add <em>файлы</em></code> копирует <em>файлы</em> (в их
    текущем состоянии) на сцену.</li>

    <li><code>git commit</code> сохраняет снимок сцены в виде коммита.</li>

    <li><code>git reset -- <em>файлы</em></code> восстанавливает файлы на
    сцене, а именно копирует <em>файлы</em> из последнего коммита на сцену.
    Используйте эту команду для отмены изменений, внесенных командой
    <code>git add <em>файлы</em></code>.  Вы также можете выполнить
    <code>git reset</code> чтобы восстановить все файлы на сцене.</li>

    <li><code>git checkout -- <em>файлы</em></code> копирует <em>файлы</em> со
    сцены в рабочую директорию.  Эту команду удобно использовать чтобы
    сбросить нежелательные изменения в рабочей директории.</li>

  </ul>

  <p>Вы можете использовать <code>git reset -p</code>,
  <code>git checkout -p</code>, и <code>git add -p</code> вместо
  (или вместе с) именами файлов, чтобы в интерактивном режиме выбирать,
  какие именно изменения будут скопированы.</p>

  <p>Также можно перепрыгнуть через сцену и сразу же получить файлы из истории
  прямо в рабочую директорию; или сделать коммит, минуя сцену.</p>

  <div class="center"><img src='basic-usage-2.svg.png'></div>

  <ul>

    <li><code>git commit -a </code> аналогичен запуску двух команд:
    <tt>git add</tt> для всех файлов, которые существовали в предыдущем
    коммите, и <tt>git commit</tt>.</li>

    <li><code>git commit <em>файлы</em></code> создает новый коммит, в основе
    которого лежат уже существующие файлы, добавляя изменения только для
    указанных <em>файлов</em>.  Одновременно, указанные <em>файлы</em> будут
    скопированы на сцену.</li>

    <li><code>git checkout HEAD -- <em>файлы</em></code> копирует
    <em>файлы</em> из последнего коммита и на сцену, и в рабочую
    директорию.</li>

  </ul>

  <h2 id="conventions">Соглашения</h2>

  <p>Иллюстрации в этой справке выдержаны в единой цветовой схеме.</p>

  <div class="center"><img src='conventions.svg.png'></div>

  <p>Коммиты раскрашены зеленым цветом и подписаны 5-ти буквенными
  идентификаторами.  Каждый коммит указывает на своего родителя зеленой
  стрелочкой.  Ветки раскрашены оранжевым цветом; ветки указывают на коммиты.
  Специальная ссылка <em>HEAD</em> указывает на текущую ветку.  На иллюстрации
  вы можете увидеть последние пять коммитов. Самый последний коммит имеет хеш
  <em>ed489</em>. <em>master</em> (текущая ветка) указывает на этот коммит,
  <em>maint</em> (другая ветка) указывает на предка <em>master</em>-ового
  коммита.</p>

  <h2 id="commands-in-detail">Подробно о командах</h2>

  <h3 id="diff">Diff</h3>

  <p>Есть много способов посмотреть изменения между коммитами.  Ниже вы
  увидите несколько простых примеров.  К каждой из этих команд можно добавить
  имена файлов в качестве дополнительного аргумента.  Так мы выведем
  информацию об изменениях только для перечисленных файлов.</p>

  <div class="center"><img src='diff.svg.png'></div>

  <h3 id="commit">Commit</h3>

  <p>Когда вы делаете коммит, git создает новый объект коммита, используя файлы
  со сцены, а текущей коммит становится родителем для нового. После этого
  указатель текущей ветки перемещается на новый коммит.  Вы это видите на
  картинке, где <em>master</em> — это текущая ветка.  До совершения коммита
  <em>master</em> указывал на коммит <em>ed489</em>.  После добавления нового
  коммита <em>f0cec</em>, родителем которого стал <em>ed489</em>, указатель
  ветки <em>master</em> был перемещен на новый коммит.</p>

  <div class="center"><img src='commit-master.svg.png'></div>

  <p>То же самое происходит, если одна ветка является предком другой ветки.
  Ниже показан пример нового коммита <em>1800b</em> в ветке <em>maint</em>,
  которая является предком ветки <em>master</em>.  После этого ветка
  <em>maint</em> уже больше не является предком ветки <em>master</em>. И в 
  случае необходимости объединения работы, проделанной в этих разделенных
  ветках, вам следует воспользоваться командой <a href='#merge'>merge</a> (что
  более предпочтительно) или <a href='#rebase'>rebase</a>.</p>

  <div class="center"><img src='commit-maint.svg.png'></div>

  <p>Если вы сделали ошибку в последнем коммите, её легко исправить с помощью
  команды <code>git commit --amend</code>.  Эта команда создает новый коммит,
  родителем которого будет родитель ошибочного коммита. Старый ошибочный
  коммит будет отброшен, конечно же если только на него не будет ещё
  каких-либо других ссылок, что маловероятно.</p>

  <div class="center"><img src='commit-amend.svg.png'></div>

  <p>Четвертый случай коммита из состояния «<a href="#detached">detached
    HEAD</a>» будет рассмотрен далее.</p>

  <h3 id="checkout">Checkout</h3>

  <p>Команда checkout используется для копирования файлов из истории или сцены
  в рабочую директорию. Также она может использоваться для переключения между
  ветками.</p>

  <p>Когда вы указываете имя файла (и/или ключ <code>-p</code>), git копирует
  эти файлы из указанного коммита на сцену и в рабочую директорию.  Например,
  <code>git checkout HEAD~ foo.c</code> копирует файл <code>foo.c</code>
  из коммита <em>HEAD~</em> (предка текущего коммита) в рабочу директорию и на
  сцену.  Если имя коммита не указано, то файл будет скопирован со сцены в
  рабочую директорию.  Следует заметить, что в приведенных выше примерах
  не было переключения между ветками.</p>

  <div class="center"><img src='checkout-files.svg.png'></div>

  <p>В том случае если мы <em>не указываем</em> имя файла, но указываем имя
  (локальной) ветки, то указатель <em>HEAD</em> будет перемещен на эту ветку
  (мы переключимся на эту ветку). При этом сцена и рабочая директория будут
  приведены в соответствие с этим коммитом. Любой файл, который присутствует в
  новом коммите (<em>a47c3</em> ниже) будет скопирован из истории; любой файл,
  который был в старом коммите (<em>ed489</em>), но отсутствует в новом, будет
  удален; любой файл, который не записан ни в одном коммите, будет
  проигнорирован.</p>

  <div class="center"><img src='checkout-branch.svg.png'></div>

  <p>В том случае если мы <em>не указываем</em> имя файла, и
  <em>не указываем</em> имя (локальной) ветки, а указываем тег, удаленная
  (remote) ветка, SHA-1 хеш коммита или что-то вроде <em>master~3</em>, то мы
  получаем безымянную ветку, называемую «<em>Detached HEAD</em>» (оторванная
  голова). Это очень полезная штука для если нам надо осмотреться в истории
  коммитов. К примеру, вам захочется скомпилировать git версии 1.6.6.1. Вы
  можете набрать <code>git checkout v1.6.6.1</code> (это тег, не ветка),
  скомпилировать, установить, а затем вернуться в другую ветку, скажем
  <code>git checkout master</code>. Тем не менее, коммиты из состояния
  «Detached HEAD» происходят по своим особым важным правилам, и мы рассмотрим
  их <a href="#detached">ниже</a>.</p>

  <div class="center"><img src='checkout-detached.svg.png'></div>

  <h3 id="detached">Коммит из состояния «Detached HEAD»</h3>

  <p>Когда мы находимся в состоянии оторванной головы
  (<em>Detached HEAD</em>), коммит совершается по тем же правилам, что и
  обычно за исключением одной маленькой особенности: ни один указатель ветки
  не будет изменен или добавлен к новому коммиту.  Вы можете представить эту
  ситуацию как работу с анонимной веткой.</p>

  <div class="center"><img src='commit-detached.svg.png'></div>

  <p>Если после такого коммита вы переключитесь в ветку <em>master</em>, то
  то коммит <em>2eecb</em>, совершенный из состояния «Detached HEAD»
  потеряется и попросту будет уничтожен очередной сборкой мусора только потому
  нет ни одного объекта, который бы на него ссылался: ни ветки, ни тега.</p>

  <div class="center"><img src='checkout-after-detached.svg.png'></div>

  <p>В том случае, если вы хотите сохранить этот коммит на будущее, вы можете
  создать на основе его новую ветку командой
  <code>git checkout -b <em>new</em></code>.</p>

  <div class="center"><img src='checkout-b-detached.svg.png'></div>

  <h3 id="reset">Reset</h3>

  <p>Команда reset перемещает указатель текущей ветки в другую позицию, и
  дополнительно может обновить сцену и рабочую директорию. Эту команду можно
  также использовать для того чтобы скопировать файл из истории на сцену, не
  задевая рабочую директорию.</p>

  <p>Если коммит указан без имен файлов, указатель ветки будет перемещен на
  этот коммит, а затем сцена приведется в соответствие с этим коммитом. Если
  мы используем ключ <code>--soft</code>, то сцена не будет изменена. Если мы
  используем ключ <code>--hard</code>, то будет обновлена и сцена, и рабочая
  директория.</p>

  <div class="center"><img src='reset-commit.svg.png'></div>

  <p>Если имя коммита не будет указано, по умолчанию оно будет <em>HEAD</em>.
  В этом случае указатель ветки не будет перемещен, но сцена (и возможно
  рабочая директория, если был использован ключ <code>--hard</code>) будут
  приведены к состоянию последнего коммита.</p>

  <div class="center"><img src='reset.svg.png'></div>

  <p>Если в команде указано имя файла (и/или ключ <code>-p</code>), то команда
  работает также как <a href='#checkout'>checkout</a> с именем файла, за
  исключением того, что только сцена (но не рабочая директория) будет
  изменена. Если вы подставите имя коммита на место двойной черты, вы сможете
  получить состояние файла из этого коммита, тогда как в случае с двойной
  чертой вы получите состояние файла из коммита, на который указывает
  <em>HEAD</em>.</p>

  <div class="center"><img src='reset-files.svg.png'></div>

  <h3 id="merge">Merge</h3>

  <p>A merge creates a new commit that incorporates changes from other
  commits.  Before merging, the stage must match the current commit.  The
  trivial case is if the other commit is an ancestor of the current commit, in
  which case nothing is done.  The next most simple is if the current commit
  is an ancestor of the other commit.  This results in a <em>fast-forward</em>
  merge.  The reference is simply moved, and then the new commit is checked
  out.</p>

  <div class="center"><img src='merge-ff.svg.png'></div>

  <p>Otherwise, a "real" merge must occur.  You can choose other strategies,
  but the default is to perform a "recursive" merge, which basically takes the
  current commit (<em>ed489</em> below), the other commit (<em>33104</em>),
  and their common ancestor (<em>b325c</em>), and performs a <a
    href='http://en.wikipedia.org/wiki/Three-way_merge'>three-way merge</a>.
  The result is saved to the working directory and the stage, and then a
  commit occurs, with an extra parent (<em>33104</em>) for the new commit.
  </p>

  <div class="center"><img src='merge.svg.png'></div>

  <h3 id="cherry-pick">Cherry Pick</h3>

  <p>The cherry-pick command "copies" a commit, creating a new commit on the
  current branch with the same message and patch as another commit.</p>

  <div class="center"><img src='cherry-pick.svg.png'></div>

  <h3 id="rebase">Rebase</h3>

  <p>A rebase is an alternative to a <a href='#merge'>merge</a> for combining
  multiple branches.  Whereas a merge creates a single commit with two
  parents, leaving a non-linear history, a rebase replays the commits from the
  current branch onto another, leaving a linear history.  In essence, this is
  an automated way of performing several <a
    href='#cherry-pick'>cherry-pick</a>s in a row.</p>

  <div class="center"><img src='rebase.svg.png'></div>

  <p>The above command takes all the commits that exist in <em>topic</em> but
  not in <em>master</em> (namely <em>169a6</em> and <em>2c33a</em>), replays
  them onto <em>master</em>, and then moves the branch head to the new tip.
  Note that the old commits will be garbage collected if they are no longer
  referenced.</p>

  <p>To limit how far back to go, use the <code>--onto</code> option.  The
  following command replays onto <em>master</em> the most recent commits on
  the current branch since <em>169a6</em> (exclusive), namely
  <em>2c33a</em>.</p>

  <div class="center"><img src='rebase-onto.svg.png'></div>

  <p>There is also <code>git rebase --interactive</code>, which allows one to
  do more complicated things than simply replaying commits, namely dropping,
  reordering, modifying, and squashing commits.  There is no obvious picture
  to draw for this; see <a
    href='http://www.kernel.org/pub/software/scm/git/docs/git-rebase.html#_interactive_mode'>git-rebase(1)</a>
  for more details.</p>

  <h2 id="technical-notes">Technical Notes</h2>

  <p>The contents of files are not actually stored in the index
  (<em>.git/index</em>) or in commit objects.  Rather, each file is stored in
  the object database (<em>.git/objects</em>) as a <em>blob</em>, identified
  by its SHA-1 hash.  The index file lists the filenames along with the
  identifier of the associated blob, as well as some other data.  For commits,
  there is an additional data type, a <em>tree</em>, also identified by its
  hash.  Trees correspond to directories in the working directory, and contain
  a list of trees and blobs corresponding to each filename within that
  directory.  Each commit stores the identifier of its top-level tree, which
  in turn contains all of the blobs and other trees associated with that
  commit.</p>

  <p>If you make a commit using a detached HEAD, the last commit really is
  referenced by something: the reflog for HEAD.  However, this will expire
  after a while, so the commit will eventually be garbage collected, similar
  to commits discarded with <code>git commit --amend</code> or <code>git
    rebase</code>.</p>

  <hr>
  <p>Copyright &copy; 2010, <a href='mailto:lodatom@gmail.com'>Mark
    Lodato</a>.  Japanese translation &copy; 2010,
  <a href='http://github.com/kazu-yamamoto'>Kazu Yamamoto</a>.
  Korean translation &copy; 2011, <a href='mailto:sean@weaveus.com'>Sean
    Lee</a>.
  This work is licensed under a <a rel="license"
    href="http://creativecommons.org/licenses/by-nc-sa/3.0/us/">Creative
    Commons Attribution-Noncommercial-Share Alike 3.0 United States
    License</a>.</p>

</body>
</html>
