<!DOCTYPE html>
<html lang="it-IT">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Guida visuale a Git</title>
  <link rel='stylesheet' type='text/css' href='visual-git-guide.css'>
  <script type="text/javascript" src='visual-git-guide.js'></script>
</head>
<body onload="replace_all_PNGs();">
  <h1 id="top">Guida visuale a Git</h1>

  <div id="language-box">
    <a>Other Languages:</a>
    <ul>
      <li><a href='index-en.html'>English</a></li>
      <li><a href='index-fr.html'>Français</a></li>
      <li class="selected">Italiano</li>
      <li><a href='index-ko.html'>한국어</a></li>
      <li><a href='index-ja.html'>日本語</a></li>
      <li><a href='index-ru.html'>Русский</a></li>
      <li><a href='index-zh-cn.html'>简体中文</a></li>
    </ul>
  </div>

  <p id="link-to-png">Se riscontri problemi di visualizzazione delle immagini, prova la versione <a
    href="?no-svg">Non-SVG</a> di questa pagina.</p>

  <p id="link-to-svg">Immagini SVG disabilitate.
  <a href="index.html">(Riattiva SVG)</a></p>

  <p>Questa pagina offre una breve guida visuale per i comandi più comuni di Git. Una 
  volta comprese le basi di Git, questo sito potrà aiutarti a fissare questi concetti.
  Se ti interessa conoscere come è stato creato questo sito visita il mio
  <a href='http://github.com/MarkLodato/visual-git-guide'>repository GitHub</a>.</p>

  <h2 id="contents">Contenuti</h2>
  <ol>
    <li><a href="#basic-usage">Utilizzo di Base</a></li>
    <li><a href="#conventions">Convenzioni</a></li>
    <li><a href="#commands-in-detail">Comandi nei dettagli</a>
      <ol>
        <li><a href="#diff">Diff</a></li>
        <li><a href="#commit">Commit</a></li>
        <li><a href="#checkout">Checkout</a></li>
        <li><a href="#detached">Commit di una HEAD isolata</a></li>
        <li><a href="#reset">Reset</a></li>
        <li><a href="#merge">Merge</a></li>
        <li><a href="#cherry-pick">Cherry Pick</a></li>
        <li><a href="#rebase">Rebase</a></li>
      </ol>
    </li>
    <li><a href="#technical-notes">Note tecniche</a></li>
  </ol>

  <h2 id="basic-usage">Utilizzo di Base</h2>

  <div class="center"><img src='basic-usage.svg.png'></div>

  <p>I quattro comandi precedenti copiano i file tra la working directory,
  lo stage (chiamato anche index) e l'history (rapprestentata dai commit).</p>

  <ul>

    <li><code>git add <em>file</em></code> copia i <em>file</em> (nel loro
    stato corrente) nello stage.</li>

    <li><code>git commit</code> crea uno snapshot dello stage sotto forma di
    commit.</li>

    <li><code>git reset -- <em>file</em></code> rimuove i file dallo stage;
    ovvero copia i <em>file</em> dell'ultimo commit nello stage. Utilizza
    questo comando per annullare un <code>git add <em>file</em></code>. Puoi anche utilizzare
    <code>git reset</code> per rimuovere tutto dallo stage.</li>

    <li><code>git checkout -- <em>file</em></code> copia i <em>file</em> dallo 
    stage alla working directory.  Utilizza questo comando per eliminare tutte le 
    modifiche locali.</li>

  </ul>

  <p>Puoi usare <code>git reset -p</code>, <code>git checkout -p</code>, oppure
  <code>git add -p</code> al posto di (o in aggiunta di) specificare i file 
  specifici, per determinare in modo interattivo, che blocchi copiare.</p>

  <p>È anche possibile evitare lo stage ed eseguire il check out di file
  direttamente dall'history o eseguire il commit senza inserire prima i 
  file nello stage.</p>

  <div class="center"><img src='basic-usage-2.svg.png'></div>

  <ul>

    <li><code>git commit -a </code> è equivalente ad eseguire <tt>git add</tt> 
    su tutti i file esistenti nell'ultimo commit, seguito da 
    <tt>git commit</tt>.</li>

    <li><code>git commit <em>file</em></code> crea un nuovo commit contenente
    i contenuti dell'ultimo commit oltre allo snapshot dei <em>file</em> presi 
    dalla working directory. Inoltre i <em>file</em> vengono copiati nello stage.</li>

    <li><code>git checkout HEAD -- <em>file</em></code> copia i <em>file</em> 
    dall'ultimo commit sia allo stage che alla working directory.</li>

  </ul>

  <h2 id="conventions">Convenzioni</h2>

  <p>Nel resto di questo documento useremo grafici come quello seguente.</p>

  <div class="center"><img src='conventions.svg.png'></div>

  <p>I commit sono mostrati in verde con ID da 5 caratteri, essi puntano al
  loro genitore. I branch sono mostrati in arancione, essi puntano a specifici
  commit. Il branch corrente è identificato dalla speciale referenza
  <em>HEAD</em>, che è "attaccata" a quel branch. In questa immagine vengono
  mostrati gli ultimi 5 commit, il più recente è il <em>ed489</em>.
  <em>master</em> (il branch corrente) punta a questo commit, mentre
  <em>maint</em> (un altro branch) punta ad un antenato del commit del <em>master</em>.</p>

  <h2 id="commands-in-detail">Comandi nei Dettagli</h2>

  <h3 id="diff">Diff</h3>

  <p>Esistono diversi modi per verificare le differenze tra i commit. Di seguito
  alcuni esempi comuni. Ognuno di questi comandi può opzionalmente ricevere
  nomi di file come ulteriori parametri per limitare le differenze solo ai file
  specificati.</p>

  <div class="center"><img src='diff.svg.png'></div>

  <h3 id="commit">Commit</h3>

  <p>Quando si esegue un commit git crea un nuovo oggetto commit utilizzando
  i file dello stage ed impostando il genitore al commit attuale. Successivamente
  punta il branch corrente a questo nuovo commit. Nell'immagine seguente il 
  branch corrente è <em>master</em>. Prima dell'esecuzione del comando <em>master</em>
  puntava a <em>ed489</em>. In seguito, un nuovo commit, <em>f0cec</em>, è stato creato
  con genitore <em>ed489</em>, quindi <em>master</em> è stato spostato sul nuovo commit.</p>

  <div class="center"><img src='commit-master.svg.png'></div>

  <p>Lo stesso processo avviene anche quando il branch corrente è un antenato
  di un altro. Di seguito vediamo un commit sul branch <em>maint</em>, che è un
  antenato di <em>master</em>, risultante in <em>1800b</em>. Di conseguenza,
  <em>maint</em> non è più un antenato di <em>master</em>.  Per unire le due 
  history sarà necessario un <a href='#merge'>merge</a> (o un <a href='#rebase'>rebase</a>).</p>

  <div class="center"><img src='commit-maint.svg.png'></div>

  <p>A volte può capitare di commettere un errore in un commit, questo è facile
  da correggere con <code>git commit --amend</code>. Quando si utilizza questo 
  comando git crea un nuovo commit con lo stesso genitore del commit corrente. 
  (Il vecchio commit verrà scartato se non ha referenze da nessuno.)</p>

  <div class="center"><img src='commit-amend.svg.png'></div>

  <p>Un quarto caso è rappresentato dal commit con <a href="#detached">HEAD isolata</a>,
  come verrà spiegato in seguito.</p>

  <h3 id="checkout">Checkout</h3>

  <p>Il comando checkout viene utilizzato per copiare i file dall'history
  (o dallo stage) alla working directory, opzionalmente per scambiare i branch.</p>

  <p>Quando un file (e/o <code>-p</code>) viene passato, git copia questi file
  da un certo commit allo stage ed alla working directory. Per esempio,
   <code>git checkout HEAD~ foo.c</code> copia il file <code>foo.c</code>
  dal commit chiamato <em>HEAD~</em> (il genitore del commit corrente) alla
  working directory, oltre ad inserirlo nello stage.  (Se non viene specificato
  un commit, i file vengono copiati dallo stage.)  Si noti che il branch corrente
  non è cambiato.</p>

  <div class="center"><img src='checkout-files.svg.png'></div>

  <p>Quando il nome di un file <em>non</em> viene passato ma la referenza è
  un branch (locale), <em>HEAD</em> viene associata a quel branch (ovvero si fa
  lo "switch a" quel branch), in seguito lo stage e la working directory vengono
  impostate per rispecchiare i contenuti di quel commit. Ogni file esistente nel 
  nuovo commit (<em>a47c3</em> qui sotto) viene copiato; ogni file esistente nel 
  vecchio commit (<em>ed489</em>) ma non nel nuovo viene eliminato; ogni file 
  esistente in entrambi viene ignorato.</p>

  <div class="center"><img src='checkout-branch.svg.png'></div>

  <p>Quando il nome di un file <em>non</em> viene passato e la referenza <em>non</em>
  è ad un branch (locale) &mdash; si ipotizzi sia un tag, un branch remoto, un 
  ID SHA-1 o qualcosa tipo <em>master~3</em> &mdash; abbiamo a che fare con un 
  branch anonimo chiamato <em>HEAD isolata</em>. Questo è utile per muoversi 
  liberamente nell'history. Supponiamo di voler compilare la versione 1.6.6.1 di git.
  Si può ricorrere a <code>git checkout v1.6.6.1</code> (che è un tag, non un branch),
  compilare, installare, e successivamente tornare ad un altro branch, per esempio
  <code>git checkout master</code>.
  Tuttavia eseguire dei commit con HEAD isolata richiede una procedura leggermente
  diversa; ne parliamo <a href="#detached">di seguito</a>.</p>

  <div class="center"><img src='checkout-detached.svg.png'></div>

  <h3 id="detached">Commit con HEAD isolata</h3>

  <p>Quando <em>HEAD</em> è isolata, i commit funzionano normalmente, l'unica 
  eccezione è data dal fatto che il branch senza nome viene aggiornato. (Si 
  può pensare ad esso come ad un branch anonimo.)</p>

  <div class="center"><img src='commit-detached.svg.png'></div>

  <p>Una volto eseguito il checkout di qualcos'altro, per esempio di <em>master</em>,
  il commit (presumibilmente) non essendo più referenziato da nessun altro
  viene perso. Si noti come dopo il comando non ci sia più alcuna referenza
  a <em>2eecb</em>.</p>

  <div class="center"><img src='checkout-after-detached.svg.png'></div>

  <p>Se, d'altronde, si volesse memorizzare questo stato, sarebbe necessario
  creare un nuovo branch con nome utilizzando <code>git checkout -b <em>name</em></code>.</p>

  <div class="center"><img src='checkout-b-detached.svg.png'></div>

  <h3 id="reset">Reset</h3>

  <p>Il comando reset sposta il branch corrente in un'altra posizione
  ed opzionalmente aggiorna lo stage e la working directory. Viene anche
  utilizzato per copiare file dall'history allo stage senza tirare in ballo
  la working directory.</p>

  <p>Se un commit viene passato senza nomi di file il branch corrente viene 
  spostato a quel commit e quindi lo stage viene aggiornato per rispecchiare
  quel commit. Se viene utilizzato <code>--hard</code> viene aggiornata anche
  la working directory. Se viene passato <code>--soft</code> non viene aggiornato
  nulla.</p>

  <div class="center"><img src='reset-commit.svg.png'></div>

  <p>Se non viene passato un commit il default utilizzato è <em>HEAD</em>.
  In questo caso il branch non viene spostato, ma lo stage (ed opzionalmente
  anche la working directory se viene passato <code>--hard</code>) vengono
  resettati ai contenuti dell'ultimo commit.</p>

  <div class="center"><img src='reset.svg.png'></div>

  <p>If a filename (and/or <code>-p</code>) is given, then the command works
  similarly to <a href='#checkout'>checkout</a> with a filename, except only
  the stage (and not the working directory) is updated.  (You may also specify
  the commit from which to take files, rather than <em>HEAD</em>.)</p>

  <div class="center"><img src='reset-files.svg.png'></div>

  <h3 id="merge">Merge</h3>

  <p>A merge creates a new commit that incorporates changes from other
  commits.  Before merging, the stage must match the current commit.  The
  trivial case is if the other commit is an ancestor of the current commit, in
  which case nothing is done.  The next most simple is if the current commit
  is an ancestor of the other commit.  This results in a <em>fast-forward</em>
  merge.  The reference is simply moved, and then the new commit is checked
  out.</p>

  <div class="center"><img src='merge-ff.svg.png'></div>

  <p>Otherwise, a "real" merge must occur.  You can choose other strategies,
  but the default is to perform a "recursive" merge, which basically takes the
  current commit (<em>ed489</em> below), the other commit (<em>33104</em>),
  and their common ancestor (<em>b325c</em>), and performs a <a
    href='http://en.wikipedia.org/wiki/Three-way_merge'>three-way merge</a>.
  The result is saved to the working directory and the stage, and then a
  commit occurs, with an extra parent (<em>33104</em>) for the new commit.
  </p>

  <div class="center"><img src='merge.svg.png'></div>

  <h3 id="cherry-pick">Cherry Pick</h3>

  <p>The cherry-pick command "copies" a commit, creating a new commit on the
  current branch with the same message and patch as another commit.</p>

  <div class="center"><img src='cherry-pick.svg.png'></div>

  <h3 id="rebase">Rebase</h3>

  <p>A rebase is an alternative to a <a href='#merge'>merge</a> for combining
  multiple branches.  Whereas a merge creates a single commit with two
  parents, leaving a non-linear history, a rebase replays the commits from the
  current branch onto another, leaving a linear history.  In essence, this is
  an automated way of performing several <a
    href='#cherry-pick'>cherry-pick</a>s in a row.</p>

  <div class="center"><img src='rebase.svg.png'></div>

  <p>The above command takes all the commits that exist in <em>topic</em> but
  not in <em>master</em> (namely <em>169a6</em> and <em>2c33a</em>), replays
  them onto <em>master</em>, and then moves the branch head to the new tip.
  Note that the old commits will be garbage collected if they are no longer
  referenced.</p>

  <p>To limit how far back to go, use the <code>--onto</code> option.  The
  following command replays onto <em>master</em> the most recent commits on
  the current branch since <em>169a6</em> (exclusive), namely
  <em>2c33a</em>.</p>

  <div class="center"><img src='rebase-onto.svg.png'></div>

  <p>There is also <code>git rebase --interactive</code>, which allows one to
  do more complicated things than simply replaying commits, namely dropping,
  reordering, modifying, and squashing commits.  There is no obvious picture
  to draw for this; see <a
    href='http://www.kernel.org/pub/software/scm/git/docs/git-rebase.html#_interactive_mode'>git-rebase(1)</a>
  for more details.</p>

  <h2 id="technical-notes">Technical Notes</h2>

  <p>The contents of files are not actually stored in the index
  (<em>.git/index</em>) or in commit objects.  Rather, each file is stored in
  the object database (<em>.git/objects</em>) as a <em>blob</em>, identified
  by its SHA-1 hash.  The index file lists the filenames along with the
  identifier of the associated blob, as well as some other data.  For commits,
  there is an additional data type, a <em>tree</em>, also identified by its
  hash.  Trees correspond to directories in the working directory, and contain
  a list of trees and blobs corresponding to each filename within that
  directory.  Each commit stores the identifier of its top-level tree, which
  in turn contains all of the blobs and other trees associated with that
  commit.</p>

  <p>If you make a commit using a detached HEAD, the last commit really is
  referenced by something: the reflog for HEAD.  However, this will expire
  after a while, so the commit will eventually be garbage collected, similar
  to commits discarded with <code>git commit --amend</code> or <code>git
    rebase</code>.</p>

  <hr>

  <p>Copyright &copy; 2010,
    <a href='mailto:lodatom@gmail.com'>Mark Lodato</a>.
  Japanese translation &copy; 2010,
    <a href='http://github.com/kazu-yamamoto'>Kazu Yamamoto</a>.
  Korean translation &copy; 2011,
    <a href='mailto:sean@weaveus.com'>Sean Lee</a>.
  Russian translation &copy; 2012,
    <a href='mailto:alex@sychev.com'>Alex Sychev</a>.
  French translation &copy; 2012,
    <a href='mailto:michel.lefranc@gmail.com'>Michel Lefranc</a>.
  Chinese translation &copy; 2012,
    <a href='mailto:ellrywych@gmail.com'>wych</a>.
  Italian translation &copy; 2012,
    <a href="mailto:daniel.londero@gmail.com">Daniel Londero</a>
  </p>

  <p><a rel="license"
    href="http://creativecommons.org/licenses/by-nc-sa/3.0/us/"><img alt=""
    src="http://i.creativecommons.org/l/by-nc-sa/3.0/us/80x15.png"></a>
  This work is licensed under a <a rel="license"
    href="http://creativecommons.org/licenses/by-nc-sa/3.0/us/">Creative
    Commons Attribution-Noncommercial-Share Alike 3.0 United States
    License</a>.</p>

  <p><a href='translate-en.html'>Want to translate into another
    language?</a></p>

</body>
</html>
